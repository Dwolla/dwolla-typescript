/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import * as openEnums from "./enums.js";
import { RFCDate } from "./rfcdate.js";

interface Candidate {
  data: unknown;
  /** Total number of fields in the parsed data */
  fieldCount: number;
  /** Number of fields which only matched due to lax parsing */
  inexactCount: number;
}

/**
 * Smart union parser that tries all schemas and returns the best match
 * based on the number of populated fields.
 */
export function smartUnion<
  Options extends readonly [z.ZodType, z.ZodType, ...z.ZodType[]],
>(
  options: Options,
): z.ZodType<
  z.output<Options[number]>,
  z.ZodTypeDef,
  z.input<Options[number]>
> {
  return z.unknown().transform((input, ctx) => {
    const candidates: Candidate[] = [];
    const errors: z.ZodIssue[][] = options.map(() => []);

    // Filter out invalid options
    for (const [i, option] of options.entries()) {
      const counter = openEnums.unrecognizedCounter();
      const result = option.safeParse(input);
      if (result.success) {
        candidates.push({
          data: result.data,
          fieldCount: 0,
          inexactCount: counter.count(),
        });
        continue;
      }
      errors[i]!.push(...result.error.issues);
    }

    // No valid options
    if (candidates.length === 0) {
      ctx.addIssue({
        code: "invalid_union",
        unionErrors: errors.map(issues => new z.ZodError(issues)),
      });
      return z.NEVER;
    }

    let best = candidates[0]!;

    // Just one valid option - short circuit
    if (candidates.length === 1) return best.data;

    // Find the best option
    for (const candidate of candidates) {
      candidate.fieldCount = countFieldsRecursive(candidate.data);
      best = better(candidate, best);
    }

    return best.data;
  }) as any;
}

function better(a: Candidate, b: Candidate): Candidate {
  if (a.fieldCount !== b.fieldCount) return a.fieldCount > b.fieldCount ? a : b;
  return a.inexactCount < b.inexactCount ? a : b;
}

/**
 * Counts the number of fields in a parsed value recursively.
 * @param `parsed` assumed to *not* contain cycles
 * fieldCount: total number of fields found
 * inexactCount: number of primitive values that are not unrecognized enum values
 */
function countFieldsRecursive(parsed: unknown): number {
  let fieldCount = 0;

  const queue: unknown[] = [parsed];
  let index = 0;

  while (index < queue.length) {
    const value = queue[index++];
    if (value === null || value === undefined) {
      continue;
    }

    // Check if it's a primitive value
    const type = typeof value;
    if (
      type === "number"
      || type === "string"
      || type === "boolean"
      || type === "bigint"
      || value instanceof Date
      || value instanceof RFCDate
    ) {
      fieldCount++;
      continue;
    }

    // Handle arrays
    if (Array.isArray(value)) {
      queue.push(...value);
      continue;
    }

    // Handle objects
    if (typeof value === "object") {
      const obj = value as Record<string, unknown>;
      queue.push(...Object.values(obj));
    }
  }

  return fieldCount;
}
