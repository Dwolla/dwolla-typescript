/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { RFCDate } from "../types/rfcdate.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { HalLink, HalLink$inboundSchema } from "./hallink.js";

export type TransferAmount1 = {
  value?: string | undefined;
  currency?: string | undefined;
};

export type Clearing = {
  source?: string | undefined;
  destination?: string | undefined;
};

export type TransferMetadata = {
  paymentId?: string | undefined;
  note?: string | undefined;
};

/**
 * Contains addenda information for the transfer
 */
export type SourceAddenda = {
  /**
   * An array containing a single string addenda value
   */
  values?: Array<string> | undefined;
};

/**
 * Describes the purpose of the transaction
 */
export const SourceCompanyEntryDescription = {
  Reversal: "REVERSAL",
  Reclaim: "RECLAIM",
  NoCheck: "NO CHECK",
  Autoenroll: "AUTOENROLL",
  Redepcheck: "REDEPCHECK",
  ReturnFee: "RETURN FEE",
  RetryPmnt: "RETRY PMNT",
  Healthcare: "HEALTHCARE",
  Payment: "PAYMENT",
} as const;
/**
 * Describes the purpose of the transaction
 */
export type SourceCompanyEntryDescription = ClosedEnum<
  typeof SourceCompanyEntryDescription
>;

/**
 * Information sent to the source/originating bank account along with the transfer
 */
export type Source = {
  /**
   * Contains addenda information for the transfer
   */
  addenda?: SourceAddenda | undefined;
  /**
   * Beneficiary of the transaction's name. In general, should match the user onboarded to the Platform's name
   */
  beneficiaryName?: string | undefined;
  /**
   * Describes the purpose of the transaction
   */
  companyEntryDescription?: SourceCompanyEntryDescription | undefined;
  /**
   * Numeric identifier of originator
   */
  companyId?: string | undefined;
  /**
   * Name of the originator
   */
  companyName?: string | undefined;
  /**
   * The date when the ACH transaction becomes effective, formatted as YYYY-MM-DD. This is typically the settlement date for the transaction
   */
  effectiveDate?: RFCDate | undefined;
  /**
   * Suggested memo line format for bank statements, structured as companyName:companyDiscretionaryData:beneficiaryName
   */
  postingData?: string | undefined;
  /**
   * Routing number of Originating Depository Financial Institution (ODFI). Identifies the financial institution that originated the ACH transaction
   */
  routingNumber?: string | undefined;
  /**
   * A unique identifier for tracing the ACH transaction through the banking network. Used for transaction tracking and reconciliation purposes
   */
  traceId?: string | undefined;
};

/**
 * Contains addenda information for the transfer
 */
export type DestinationAddenda = {
  /**
   * An array containing a single string addenda value
   */
  values?: Array<string> | undefined;
};

/**
 * Describes the purpose of the transaction
 */
export const DestinationCompanyEntryDescription = {
  Reversal: "REVERSAL",
  Reclaim: "RECLAIM",
  NoCheck: "NO CHECK",
  Autoenroll: "AUTOENROLL",
  Redepcheck: "REDEPCHECK",
  ReturnFee: "RETURN FEE",
  RetryPmnt: "RETRY PMNT",
  Healthcare: "HEALTHCARE",
  Payment: "PAYMENT",
} as const;
/**
 * Describes the purpose of the transaction
 */
export type DestinationCompanyEntryDescription = ClosedEnum<
  typeof DestinationCompanyEntryDescription
>;

/**
 * Information sent to the destination/receiving bank account along with the transfer
 */
export type AchDetailsDestination = {
  /**
   * Contains addenda information for the transfer
   */
  addenda?: DestinationAddenda | undefined;
  /**
   * Beneficiary of the transaction's name. In general, should match the user onboarded to the Platform's name
   */
  beneficiaryName?: string | undefined;
  /**
   * Describes the purpose of the transaction
   */
  companyEntryDescription?: DestinationCompanyEntryDescription | undefined;
  /**
   * Numeric identifier of originator
   */
  companyId?: string | undefined;
  /**
   * Name of the originator
   */
  companyName?: string | undefined;
  /**
   * The date when the ACH transaction becomes effective, formatted as YYYY-MM-DD. This is typically the settlement date for the transaction
   */
  effectiveDate?: RFCDate | undefined;
  /**
   * Suggested memo line format for bank statements, structured as companyName:companyDiscretionaryData:beneficiaryName
   */
  postingData?: string | undefined;
  /**
   * Routing number of Originating Depository Financial Institution (ODFI). Identifies the financial institution that originated the ACH transaction
   */
  routingNumber?: string | undefined;
  /**
   * A unique identifier for tracing the ACH transaction through the banking network. Used for transaction tracking and reconciliation purposes
   */
  traceId?: string | undefined;
};

/**
 * ACH-specific details for the transfer. Present when transfer was processed via ACH network.
 */
export type AchDetails = {
  /**
   * Information sent to the source/originating bank account along with the transfer
   */
  source?: Source | undefined;
  /**
   * Information sent to the destination/receiving bank account along with the transfer
   */
  destination?: AchDetailsDestination | undefined;
};

/**
 * RTP destination details with network identifiers
 */
export type RtpDetailsDestination = {
  /**
   * Remittance information included in the transfer request
   */
  remittanceData?: string | undefined;
  /**
   * Unique identifier for the transfer within the RTP network
   */
  networkId?: string | undefined;
  /**
   * End-to-end reference identifier for the RTP transfer
   */
  endToEndReferenceId?: string | undefined;
};

/**
 * Real-Time Payments (RTP) network specific details. Present when transfer was processed via RTP network.
 */
export type RtpDetails = {
  /**
   * RTP destination details with network identifiers
   */
  destination?: RtpDetailsDestination | undefined;
};

/**
 * FedNow destination details with network identifiers
 */
export type FedNowDetailsDestination = {
  /**
   * Remittance information included in the transfer request
   */
  remittanceData?: string | undefined;
  /**
   * Unique identifier for the transfer within the FedNow network
   */
  networkId?: string | undefined;
  /**
   * End-to-end reference identifier for the FedNow transfer
   */
  endToEndReferenceId?: string | undefined;
};

/**
 * FedNow Service network specific details. Present when transfer was processed via FedNow network.
 */
export type FedNowDetails = {
  /**
   * FedNow destination details with network identifiers
   */
  destination?: FedNowDetailsDestination | undefined;
};

/**
 * The payment network used to process the transfer
 */
export const DestinationEnum = {
  RealTimePayments: "real-time-payments",
  FedNow: "fed-now",
} as const;
/**
 * The payment network used to process the transfer
 */
export type DestinationEnum = ClosedEnum<typeof DestinationEnum>;

export type TransferProcessingChannel = {
  /**
   * The payment network used to process the transfer
   */
  destination?: DestinationEnum | undefined;
};

export type Transfer = {
  links?: { [k: string]: HalLink } | undefined;
  id?: string | undefined;
  status?: string | undefined;
  amount?: TransferAmount1 | undefined;
  created?: Date | undefined;
  clearing?: Clearing | undefined;
  metadata?: TransferMetadata | undefined;
  /**
   * ACH-specific details for the transfer. Present when transfer was processed via ACH network.
   */
  achDetails?: AchDetails | undefined;
  /**
   * Real-Time Payments (RTP) network specific details. Present when transfer was processed via RTP network.
   */
  rtpDetails?: RtpDetails | undefined;
  /**
   * FedNow Service network specific details. Present when transfer was processed via FedNow network.
   */
  fedNowDetails?: FedNowDetails | undefined;
  correlationId?: string | undefined;
  processingChannel?: TransferProcessingChannel | undefined;
};

/** @internal */
export const TransferAmount1$inboundSchema: z.ZodType<
  TransferAmount1,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
  currency: z.string().optional(),
});

export function transferAmount1FromJSON(
  jsonString: string,
): SafeParseResult<TransferAmount1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferAmount1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferAmount1' from JSON`,
  );
}

/** @internal */
export const Clearing$inboundSchema: z.ZodType<
  Clearing,
  z.ZodTypeDef,
  unknown
> = z.object({
  source: z.string().optional(),
  destination: z.string().optional(),
});

export function clearingFromJSON(
  jsonString: string,
): SafeParseResult<Clearing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Clearing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Clearing' from JSON`,
  );
}

/** @internal */
export const TransferMetadata$inboundSchema: z.ZodType<
  TransferMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  note: z.string().optional(),
});

export function transferMetadataFromJSON(
  jsonString: string,
): SafeParseResult<TransferMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferMetadata' from JSON`,
  );
}

/** @internal */
export const SourceAddenda$inboundSchema: z.ZodType<
  SourceAddenda,
  z.ZodTypeDef,
  unknown
> = z.object({
  values: z.array(z.string()).optional(),
});

export function sourceAddendaFromJSON(
  jsonString: string,
): SafeParseResult<SourceAddenda, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SourceAddenda$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SourceAddenda' from JSON`,
  );
}

/** @internal */
export const SourceCompanyEntryDescription$inboundSchema: z.ZodNativeEnum<
  typeof SourceCompanyEntryDescription
> = z.nativeEnum(SourceCompanyEntryDescription);

/** @internal */
export const Source$inboundSchema: z.ZodType<Source, z.ZodTypeDef, unknown> = z
  .object({
    addenda: z.lazy(() => SourceAddenda$inboundSchema).optional(),
    beneficiaryName: z.string().optional(),
    companyEntryDescription: SourceCompanyEntryDescription$inboundSchema
      .optional(),
    companyId: z.string().optional(),
    companyName: z.string().optional(),
    effectiveDate: z.string().transform(v => new RFCDate(v)).optional(),
    postingData: z.string().optional(),
    routingNumber: z.string().optional(),
    traceId: z.string().optional(),
  });

export function sourceFromJSON(
  jsonString: string,
): SafeParseResult<Source, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Source$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Source' from JSON`,
  );
}

/** @internal */
export const DestinationAddenda$inboundSchema: z.ZodType<
  DestinationAddenda,
  z.ZodTypeDef,
  unknown
> = z.object({
  values: z.array(z.string()).optional(),
});

export function destinationAddendaFromJSON(
  jsonString: string,
): SafeParseResult<DestinationAddenda, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DestinationAddenda$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DestinationAddenda' from JSON`,
  );
}

/** @internal */
export const DestinationCompanyEntryDescription$inboundSchema: z.ZodNativeEnum<
  typeof DestinationCompanyEntryDescription
> = z.nativeEnum(DestinationCompanyEntryDescription);

/** @internal */
export const AchDetailsDestination$inboundSchema: z.ZodType<
  AchDetailsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  addenda: z.lazy(() => DestinationAddenda$inboundSchema).optional(),
  beneficiaryName: z.string().optional(),
  companyEntryDescription: DestinationCompanyEntryDescription$inboundSchema
    .optional(),
  companyId: z.string().optional(),
  companyName: z.string().optional(),
  effectiveDate: z.string().transform(v => new RFCDate(v)).optional(),
  postingData: z.string().optional(),
  routingNumber: z.string().optional(),
  traceId: z.string().optional(),
});

export function achDetailsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<AchDetailsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AchDetailsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AchDetailsDestination' from JSON`,
  );
}

/** @internal */
export const AchDetails$inboundSchema: z.ZodType<
  AchDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  source: z.lazy(() => Source$inboundSchema).optional(),
  destination: z.lazy(() => AchDetailsDestination$inboundSchema).optional(),
});

export function achDetailsFromJSON(
  jsonString: string,
): SafeParseResult<AchDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AchDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AchDetails' from JSON`,
  );
}

/** @internal */
export const RtpDetailsDestination$inboundSchema: z.ZodType<
  RtpDetailsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  remittanceData: z.string().optional(),
  networkId: z.string().optional(),
  endToEndReferenceId: z.string().optional(),
});

export function rtpDetailsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<RtpDetailsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RtpDetailsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RtpDetailsDestination' from JSON`,
  );
}

/** @internal */
export const RtpDetails$inboundSchema: z.ZodType<
  RtpDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  destination: z.lazy(() => RtpDetailsDestination$inboundSchema).optional(),
});

export function rtpDetailsFromJSON(
  jsonString: string,
): SafeParseResult<RtpDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RtpDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RtpDetails' from JSON`,
  );
}

/** @internal */
export const FedNowDetailsDestination$inboundSchema: z.ZodType<
  FedNowDetailsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  remittanceData: z.string().optional(),
  networkId: z.string().optional(),
  endToEndReferenceId: z.string().optional(),
});

export function fedNowDetailsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<FedNowDetailsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FedNowDetailsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FedNowDetailsDestination' from JSON`,
  );
}

/** @internal */
export const FedNowDetails$inboundSchema: z.ZodType<
  FedNowDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  destination: z.lazy(() => FedNowDetailsDestination$inboundSchema).optional(),
});

export function fedNowDetailsFromJSON(
  jsonString: string,
): SafeParseResult<FedNowDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FedNowDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FedNowDetails' from JSON`,
  );
}

/** @internal */
export const DestinationEnum$inboundSchema: z.ZodNativeEnum<
  typeof DestinationEnum
> = z.nativeEnum(DestinationEnum);

/** @internal */
export const TransferProcessingChannel$inboundSchema: z.ZodType<
  TransferProcessingChannel,
  z.ZodTypeDef,
  unknown
> = z.object({
  destination: DestinationEnum$inboundSchema.optional(),
});

export function transferProcessingChannelFromJSON(
  jsonString: string,
): SafeParseResult<TransferProcessingChannel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferProcessingChannel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferProcessingChannel' from JSON`,
  );
}

/** @internal */
export const Transfer$inboundSchema: z.ZodType<
  Transfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  _links: z.record(HalLink$inboundSchema).optional(),
  id: z.string().optional(),
  status: z.string().optional(),
  amount: z.lazy(() => TransferAmount1$inboundSchema).optional(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  clearing: z.lazy(() => Clearing$inboundSchema).optional(),
  metadata: z.lazy(() => TransferMetadata$inboundSchema).optional(),
  achDetails: z.lazy(() => AchDetails$inboundSchema).optional(),
  rtpDetails: z.lazy(() => RtpDetails$inboundSchema).optional(),
  fedNowDetails: z.lazy(() => FedNowDetails$inboundSchema).optional(),
  correlationId: z.string().optional(),
  processingChannel: z.lazy(() => TransferProcessingChannel$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

export function transferFromJSON(
  jsonString: string,
): SafeParseResult<Transfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transfer' from JSON`,
  );
}
