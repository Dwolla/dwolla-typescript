/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { DwollaCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { DwollaError } from "../models/errors/dwollaerror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve mass payment item
 *
 * @remarks
 * Retrieve detailed information for a specific mass payment item by its unique identifier. Returns item status, amount, metadata, and links to the parent mass payment, associated transfer, and destination funding source. Use this endpoint to check the processing status and details of an individual item within a mass payment batch.
 */
export function massPaymentsItemsGet(
  client: DwollaCore,
  request: operations.GetMassPaymentItemRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.MassPaymentItem,
    | errors.GetMassPaymentItemForbiddenDwollaV1HalJSONError
    | errors.GetMassPaymentItemNotFoundDwollaV1HalJSONError
    | DwollaError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: DwollaCore,
  request: operations.GetMassPaymentItemRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.MassPaymentItem,
      | errors.GetMassPaymentItemForbiddenDwollaV1HalJSONError
      | errors.GetMassPaymentItemNotFoundDwollaV1HalJSONError
      | DwollaError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.GetMassPaymentItemRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    itemId: encodeSimple("itemId", payload.itemId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/mass-payment-items/{itemId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/vnd.dwolla.v1.hal+json",
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getMassPaymentItem",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "404", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.MassPaymentItem,
    | errors.GetMassPaymentItemForbiddenDwollaV1HalJSONError
    | errors.GetMassPaymentItemNotFoundDwollaV1HalJSONError
    | DwollaError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, models.MassPaymentItem$inboundSchema, {
      ctype: "application/vnd.dwolla.v1.hal+json",
    }),
    M.jsonErr(
      403,
      errors.GetMassPaymentItemForbiddenDwollaV1HalJSONError$inboundSchema,
      { ctype: "application/vnd.dwolla.v1.hal+json" },
    ),
    M.jsonErr(
      404,
      errors.GetMassPaymentItemNotFoundDwollaV1HalJSONError$inboundSchema,
      { ctype: "application/vnd.dwolla.v1.hal+json" },
    ),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
